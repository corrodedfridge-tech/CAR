```html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Infinite 3D Car Racing</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { overflow: hidden; background: #000; }
canvas { display: block; }
#ui {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; color: white; font-family: Arial, sans-serif;
}
#speed { position: absolute; bottom: 30px; right: 30px; font-size: 48px; font-weight: bold; text-shadow: 2px 2px 4px #000; }
#score { position: absolute; top: 20px; left: 20px; font-size: 28px; font-weight: bold; text-shadow: 2px 2px 4px #000; }
#gear { position: absolute; bottom: 80px; right: 50px; font-size: 36px; font-weight: bold; text-shadow: 2px 2px 4px #000; color: #ff4444; }
#message {
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    font-size: 48px; font-weight: bold; text-align: center;
    text-shadow: 3px 3px 6px #000; pointer-events: auto;
    line-height: 1.5;
}
#controls {
    position: absolute; bottom: 20px; left: 20px; font-size: 13px;
    opacity: 0.6; text-shadow: 1px 1px 2px #000;
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">
    <div id="score">Score: 0</div>
    <div id="speed">0 km/h</div>
    <div id="gear">N</div>
    <div id="controls">WASD / Arrows: Drive | Space: Brake</div>
    <div id="message">üèéÔ∏è INFINITE RACER<br><span style="font-size:24px">Press ENTER to start</span></div>
</div>
<script>
const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
if (!gl) { alert('WebGL not supported'); }

// Resize
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener('resize', resize);
resize();

// Shader sources
const VS = `
attribute vec3 aPos;
attribute vec3 aNorm;
attribute vec3 aColor;
attribute vec2 aUV;
uniform mat4 uProj, uView, uModel;
varying vec3 vColor, vNorm, vWorldPos;
varying vec2 vUV;
varying float vFog;
void main() {
    vec4 world = uModel * vec4(aPos, 1.0);
    vWorldPos = world.xyz;
    gl_Position = uProj * uView * world;
    vColor = aColor;
    vNorm = mat3(uModel) * aNorm;
    vUV = aUV;
    float dist = length((uView * world).xyz);
    vFog = clamp(exp(-dist * 0.0012), 0.0, 1.0);
}`;

const FS = `
precision mediump float;
varying vec3 vColor, vNorm, vWorldPos;
varying vec2 vUV;
varying float vFog;
uniform vec3 uLightDir;
uniform vec3 uFogColor;
uniform float uTime;
void main() {
    vec3 n = normalize(vNorm);
    float diff = max(dot(n, normalize(uLightDir)), 0.0);
    float amb = 0.35;
    vec3 col = vColor * (amb + diff * 0.65);
    col = mix(uFogColor, col, vFog);
    gl_FragColor = vec4(col, 1.0);
}`;

function createShader(src, type) {
    let s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(s));
    return s;
}

let prog = gl.createProgram();
gl.attachShader(prog, createShader(VS, gl.VERTEX_SHADER));
gl.attachShader(prog, createShader(FS, gl.FRAGMENT_SHADER));
gl.linkProgram(prog);
gl.useProgram(prog);

let aPos = gl.getAttribLocation(prog, 'aPos');
let aNorm = gl.getAttribLocation(prog, 'aNorm');
let aColor = gl.getAttribLocation(prog, 'aColor');
let aUV = gl.getAttribLocation(prog, 'aUV');
let uProj = gl.getUniformLocation(prog, 'uProj');
let uView = gl.getUniformLocation(prog, 'uView');
let uModel = gl.getUniformLocation(prog, 'uModel');
let uLightDir = gl.getUniformLocation(prog, 'uLightDir');
let uFogColor = gl.getUniformLocation(prog, 'uFogColor');
let uTime = gl.getUniformLocation(prog, 'uTime');

gl.enable(gl.DEPTH_TEST);
gl.enable(gl.CULL_FACE);
gl.clearColor(0.05, 0.05, 0.15, 1);

// Matrix math
function mat4() { let m = new Float32Array(16); m[0]=m[5]=m[10]=m[15]=1; return m; }
function perspective(fov, aspect, near, far) {
    let m = new Float32Array(16);
    let f = 1 / Math.tan(fov / 2);
    m[0] = f / aspect; m[5] = f;
    m[10] = (far + near) / (near - far); m[11] = -1;
    m[14] = 2 * far * near / (near - far);
    return m;
}
function lookAt(eye, target, up) {
    let m = new Float32Array(16);
    let zx = eye[0]-target[0], zy = eye[1]-target[1], zz = eye[2]-target[2];
    let zl = Math.sqrt(zx*zx+zy*zy+zz*zz); zx/=zl; zy/=zl; zz/=zl;
    let xx = up[1]*zz-up[2]*zy, xy = up[2]*zx-up[0]*zz, xz = up[0]*zy-up[1]*zx;
    let xl = Math.sqrt(xx*xx+xy*xy+xz*xz); xx/=xl; xy/=xl; xz/=xl;
    let yx = zy*xz-zz*xy, yy = zz*xx-zx*xz, yz = zx*xy-zy*xx;
    m[0]=xx; m[1]=yx; m[2]=zx;
    m[4]=xy; m[5]=yy; m[6]=zy;
    m[8]=xz; m[9]=yz; m[10]=zz;
    m[12]=-(xx*eye[0]+xy*eye[1]+xz*eye[2]);
    m[13]=-(yx*eye[0]+yy*eye[1]+yz*eye[2]);
    m[14]=-(zx*eye[0]+zy*eye[1]+zz*eye[2]);
    m[15]=1;
    return m;
}
function translate(m, x, y, z) {
    let r = new Float32Array(m);
    r[12] += m[0]*x + m[4]*y + m[8]*z;
    r[13] += m[1]*x + m[5]*y + m[9]*z;
    r[14] += m[2]*x + m[6]*y + m[10]*z;
    return r;
}
function rotateY(m, a) {
    let r = new Float32Array(m);
    let c = Math.cos(a), s = Math.sin(a);
    r[0] = m[0]*c + m[8]*s; r[2] = m[2]*c + m[10]*s;
    r[4] = m[4]*c + m[12-4]*s; 
    r[8] = m[8]*c - m[0]*s; r[10] = m[10]*c - m[2]*s;
    r[4] = m[4]*c; r[8] = -m[0]*s + m[8]*c;
    // redo properly
    let o = new Float32Array(m);
    r[0]=o[0]*c+o[8]*s; r[1]=o[1]*c+o[9]*s; r[2]=o[2]*c+o[10]*s; r[3]=o[3]*c+o[11]*s;
    r[8]=o[8]*c-o[0]*s; r[9]=o[9]*c-o[1]*s; r[10]=o[10]*c-o[2]*s; r[11]=o[11]*c-o[3]*s;
    r[4]=o[4]; r[5]=o[5]; r[6]=o[6]; r[7]=o[7];
    r[12]=o[12]; r[13]=o[13]; r[14]=o[14]; r[15]=o[15];
    return r;
}
function scaleM(m, x, y, z) {
    let r = new Float32Array(m);
    r[0]*=x; r[1]*=x; r[2]*=x; r[3]*=x;
    r[4]*=y; r[5]*=y; r[6]*=y; r[7]*=y;
    r[8]*=z; r[9]*=z; r[10]*=z; r[11]*=z;
    return r;
}

// Mesh builder
function createMesh(verts, norms, cols, indices) {
    let vao = {};
    vao.count = indices.length;
    
    let vb = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vb);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.STATIC_DRAW);
    vao.vb = vb;
    
    let nb = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, nb);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(norms), gl.STATIC_DRAW);
    vao.nb = nb;
    
    let cb = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, cb);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cols), gl.STATIC_DRAW);
    vao.cb = cb;
    
    let ib = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
    vao.ib = ib;
    
    return vao;
}

function drawMesh(mesh, model) {
    gl.uniformMatrix4fv(uModel, false, model);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vb);
    gl.enableVertexAttribArray(aPos);
    gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, mesh.nb);
    gl.enableVertexAttribArray(aNorm);
    gl.vertexAttribPointer(aNorm, 3, gl.FLOAT, false, 0, 0);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, mesh.cb);
    gl.enableVertexAttribArray(aColor);
    gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);
    
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh.ib);
    gl.drawElements(gl.TRIANGLES, mesh.count, gl.UNSIGNED_SHORT, 0);
}

// Build box mesh
function buildBox(w, h, d, r, g, b) {
    let hw = w/2, hh = h/2, hd = d/2;
    let v = [
        -hw,-hh,-hd, hw,-hh,-hd, hw,hh,-hd, -hw,hh,-hd,
        -hw,-hh,hd, hw,-hh,hd, hw,hh,hd, -hw,hh,hd,
        -hw,-hh,-hd, -hw,hh,-hd, -hw,hh,hd, -hw,-hh,hd,
        hw,-hh,-hd, hw,hh,-hd, hw,hh,hd, hw,-hh,hd,
        -hw,hh,-hd, hw,hh,-hd, hw,hh,hd, -hw,hh,hd,
        -hw,-hh,-hd, hw,-hh,-hd, hw,-hh,hd, -hw,-hh,hd,
    ];
    let n = [
        0,0,-1, 0,0,-1, 0,0,-1, 0,0,-1,
        0,0,1, 0,0,1, 0,0,1, 0,0,1,
        -1,0,0, -1,0,0, -1,0,0, -1,0,0,
        1,0,0, 1,0,0, 1,0,0, 1,0,0,
        0,1,0, 0,1,0, 0,1,0, 0,1,0,
        0,-1,0, 0,-1,0, 0,-1,0, 0,-1,0,
    ];
    let c = [];
    for (let i = 0; i < 24; i++) c.push(r, g, b);
    let idx = [];
    for (let f = 0; f < 6; f++) {
        let o = f * 4;
        idx.push(o,o+1,o+2, o,o+2,o+3);
    }
    return createMesh(v, n, c, idx);
}

// Build cylinder (for trees)
function buildCylinder(radius, height, segs, r, g, b) {
    let v = [], n = [], c = [], idx = [];
    for (let i = 0; i <= segs; i++) {
        let a = (i / segs) * Math.PI * 2;
        let x = Math.cos(a) * radius, z = Math.sin(a) * radius;
        v.push(x, 0, z);
        n.push(Math.cos(a), 0, Math.sin(a));
        c.push(r, g, b);
        v.push(x, height, z);
        n.push(Math.cos(a), 0, Math.sin(a));
        c.push(r * 0.8, g * 0.8, b * 0.8);
    }
    for (let i = 0; i < segs; i++) {
        let a = i * 2, b2 = a + 1, c2 = a + 2, d = a + 3;
        idx.push(a, c2, b2, b2, c2, d);
    }
    return createMesh(v, n, c, idx);
}

// Build cone (for tree tops)
function buildCone(radius, height, segs, r, g, b) {
    let v = [], no = [], co = [], idx = [];
    // tip
    v.push(0, height, 0);
    no.push(0, 1, 0);
    co.push(r * 1.1, g * 1.1, b * 1.1);
    for (let i = 0; i <= segs; i++) {
        let a = (i / segs) * Math.PI * 2;
        let x = Math.cos(a) * radius, z = Math.sin(a) * radius;
        v.push(x, 0, z);
        let ny = radius / height;
        let nl = Math.sqrt(1 + ny * ny);
        no.push(Math.cos(a) / nl, ny / nl, Math.sin(a) / nl);
        co.push(r, g, b);
    }
    for (let i = 1; i <= segs; i++) {
        idx.push(0, i, i + 1);
    }
    return createMesh(v, no, co, idx);
}

// Road chunk building
const ROAD_W = 12;
const CHUNK_LEN = 20;
const SEGMENTS_PER_CHUNK = 10;
const SEG_LEN = CHUNK_LEN / SEGMENTS_PER_CHUNK;

class RoadChunk {
    constructor(index, prevEnd) {
        this.index = index;
        this.zStart = index * CHUNK_LEN;
        this.curve = 0;
        this.hillFreq = 0;
        this.hillAmp = 0;
        this.objects = [];
        this.mesh = null;
        this.barrierMeshL = null;
        this.barrierMeshR = null;
        this.groundMesh = null;
        
        // Procedural params based on index
        let seed = index * 7919;
        let hash = (s) => { s = ((s >> 16) ^ s) * 0x45d9f3b; s = ((s >> 16) ^ s) * 0x45d9f3b; return ((s >> 16) ^ s) / 2147483647; };
        let h1 = hash(seed), h2 = hash(seed + 1), h3 = hash(seed + 2);
        
        this.curve = (h1 - 0.5) * 0.08;
        this.hillAmp = h2 * 4;
        this.hillFreq = 0.3 + h3 * 0.5;
        
        this.generate(prevEnd);
    }
    
    getY(localZ) {
        return Math.sin((this.zStart + localZ) * this.hillFreq * 0.1) * this.hillAmp;
    }
    
    getCurveX(localZ) {
        let t = localZ / CHUNK_LEN;
        return this.curve * t * t * CHUNK_LEN * 5;
    }
    
    generate(prevEnd) {
        let verts = [], norms = [], cols = [], indices = [];
        let gverts = [], gnorms = [], gcols = [], gindices = [];
        let bvL = [], bnL = [], bcL = [], biL = [];
        let bvR = [], bnR = [], bcR = [], biR = [];
        
        let vi = 0, gi = 0, bli = 0, bri = 0;
        
        for (let s = 0; s < SEGMENTS_PER_CHUNK; s++) {
            let z0 = s * SEG_LEN;
            let z1 = (s + 1) * SEG_LEN;
            let y0 = this.getY(z0);
            let y1 = this.getY(z1);
            let cx0 = this.getCurveX(z0);
            let cx1 = this.getCurveX(z1);
            
            let dark = s % 2 === 0;
            let roadR = dark ? 0.25 : 0.28;
            let roadG = dark ? 0.25 : 0.28;
            let roadB = dark ? 0.27 : 0.30;
            
            // Road surface
            let p0 = vi;
            verts.push(cx0 - ROAD_W, y0, z0, cx0 + ROAD_W, y0, z0, cx1 + ROAD_W, y1, z1, cx1 - ROAD_W, y1, z1);
            for (let i = 0; i < 4; i++) { norms.push(0, 1, 0); cols.push(roadR, roadG, roadB); }
            indices.push(p0, p0+1, p0+2, p0, p0+2, p0+3);
            vi += 4;
            
            // Lane markings (white dashes)
            if (!dark) {
                let lw = 0.15;
                for (let lane = -1; lane <= 1; lane++) {
                    if (lane === 0) continue;
                    let lx0 = cx0 + lane * (ROAD_W / 2);
                    let lx1 = cx1 + lane * (ROAD_W / 2);
                    let p = vi;
                    verts.push(lx0 - lw, y0 + 0.02, z0, lx0 + lw, y0 + 0.02, z0, lx1 + lw, y1 + 0.02, z1, lx1 - lw, y1 + 0.02, z1);
                    for (let i = 0; i < 4; i++) { norms.push(0, 1, 0); cols.push(0.9, 0.9, 0.9); }
                    indices.push(p, p+1, p+2, p, p+2, p+3);
                    vi += 4;
                }
            }
            
            // Center line (yellow)
            {
                let lw = 0.1;
                let p = vi;
                verts.push(cx0 - lw, y0 + 0.02, z0, cx0 + lw, y0 + 0.02, z0, cx1 + lw, y1 + 0.02, z1, cx1 - lw, y1 + 0.02, z1);
                for (let i = 0; i < 4; i++) { norms.push(0, 1, 0); cols.push(0.9, 0.7, 0.1); }
                indices.push(p, p+1, p+2, p, p+2, p+3);
                vi += 4;
            }
            
            // Rumble strips / curbs
            let rumbleW = 0.8;
            let rumbleR = dark ? 0.8 : 0.9, rumbleG = dark ? 0.1 : 0.9, rumbleB = dark ? 0.1 : 0.9;
            for (let side of [-1, 1]) {
                let ex0 = cx0 + side * ROAD_W;
                let ex1 = cx1 + side * ROAD_W;
                let p = vi;
                verts.push(ex0, y0, z0, ex0 + side * rumbleW, y0, z0, ex1 + side * rumbleW, y1, z1, ex1, y1, z1);
                for (let i = 0; i < 4; i++) { norms.push(0, 1, 0); cols.push(rumbleR, rumbleG, rumbleB); }
                indices.push(p, p+1, p+2, p, p+2, p+3);
                vi += 4;
            }
            
            // Ground patches
            let groundW = 60;
            let grassR = dark ? 0.08 : 0.1, grassG = dark ? 0.35 : 0.4, grassB = dark ? 0.05 : 0.06;
            for (let side of [-1, 1]) {
                let gx0 = cx0 + side * (ROAD_W + rumbleW);
                let gx1 = cx1 + side * (ROAD_W + rumbleW);
                let gx0e = cx0 + side * groundW;
                let gx1e = cx1 + side * groundW;
                let p = gi;
                gverts.push(gx0, y0 - 0.05, z0, gx0e, y0 - 0.3, z0, gx1e, y1 - 0.3, z1, gx1, y1 - 0.05, z1);
                for (let i = 0; i < 4; i++) { gnorms.push(0, 1, 0); gcols.push(grassR, grassG, grassB); }
                gindices.push(p, p+1, p+2, p, p+2, p+3);
                gi += 4;
            }
            
            // Barriers
            let barrierH = 1.0;
            let barrierW = 0.3;
            let br = 0.5, bg = 0.5, bb = 0.5;
            // Left barrier
            {
                let bx0 = cx0 - ROAD_W - rumbleW - barrierW;
                let bx1 = cx1 - ROAD_W - rumbleW - barrierW;
                let p = bli;
                // front face
                bvL.push(bx0, y0, z0, bx0 + barrierW, y0, z0, bx0 + barrierW, y0 + barrierH, z0, bx0, y0 + barrierH, z0);
                // back face  
                bvL.push(bx1, y1, z1, bx1 + barrierW, y1, z1, bx1 + barrierW, y1 + barrierH, z1, bx1, y1 + barrierH, z1);
                // top
                bvL.push(bx0, y0 + barrierH, z0, bx0 + barrierW, y0 + barrierH, z0, bx1 + barrierW, y1 + barrierH, z1, bx1, y1 + barrierH, z1);
                // outer side
                bvL.push(bx0, y0, z0, bx0, y0 + barrierH, z0, bx1, y1 + barrierH, z1, bx1, y1, z1);
                for (let i = 0; i < 4; i++) { bnL.push(0, 0, -1); bcL.push(br, bg, bb); }
                for (let i = 0; i < 4; i++) { bnL.push(0, 0, 1); bcL.push(br*0.8, bg*0.8, bb*0.8); }
                for (let i = 0; i < 4; i++) { bnL.push(0, 1, 0); bcL.push(br*0.9, bg*0.9, bb*0.9); }
                for (let i = 0; i < 4; i++) { bnL.push(-1, 0, 0); bcL.push(br*0.7, bg*0.7, bb*0.7); }
                biL.push(p,p+1,p+2, p,p+2,p+3);
                biL.push(p+4,p+6,p+5, p+4,p+7,p+6);
                biL.push(p+8,p+9,p+10, p+8,p+10,p+11);
                biL.push(p+12,p+13,p+14, p+12,p+14,p+15);
                bli += 16;
            }
            // Right barrier
            {
                let bx0 = cx0 + ROAD_W + rumbleW;
                let bx1 = cx1 + ROAD_W + rumbleW;
                let p = bri;
                bvR.push(bx0, y0, z0, bx0 + barrierW, y0, z0, bx0 + barrierW, y0 + barrierH, z0, bx0, y0 + barrierH, z0);
                bvR.push(bx1, y1, z1, bx1 + barrierW, y1, z1, bx1 + barrierW, y1 + barrierH, z1, bx1, y1 + barrierH, z1);
                bvR.push(bx0, y0 + barrierH, z0, bx0 + barrierW, y0 + barrierH, z0, bx1 + barrierW, y1 + barrierH, z1, bx1, y1 + barrierH, z1);
                bvR.push(bx0 + barrierW, y0, z0, bx0 + barrierW, y0 + barrierH, z0, bx1 + barrierW, y1 + barrierH, z1, bx1 + barrierW, y1, z1);
                for (let i = 0; i < 4; i++) { bnR.push(0, 0, -1); bcR.push(br, bg, bb); }
                for (let i = 0; i < 4; i++) { bnR.push(0, 0, 1); bcR.push(br*0.8, bg*0.8, bb*0.8); }
                for (let i = 0; i < 4; i++) { bnR.push(0, 1, 0); bcR.push(br*0.9, bg*0.9, bb*0.9); }
                for (let i = 0; i < 4; i++) { bnR.push(1, 0, 0); bcR.push(br*0.7, bg*0.7, bb*0.7); }
                biR.push(p,p+1,p+2, p,p+2,p+3);
                biR.push(p+4,p+6,p+5, p+4,p+7,p+6);
                biR.push(p+8,p+9,p+10, p+8,p+10,p+11);
                biR.push(p+12,p+13,p+14, p+12,p+14,p+15);
                bri += 16;
            }
        }
        
        this.mesh = createMesh(verts, norms, cols, indices);
        this.groundMesh = createMesh(gverts, gnorms, gcols, gindices);
        if (biL.length) this.barrierMeshL = createMesh(bvL, bnL, bcL, biL);
        if (biR.length) this.barrierMeshR = createMesh(bvR, bnR, bcR, biR);
        
        // Generate scenery objects
        let hash2 = (s) => { s = ((s >> 16) ^ s) * 0x45d9f3b; s = ((s >> 16) ^ s) * 0x45d9f3b; return (((s >> 16) ^ s) & 0x7fffffff) / 2147483647; };
        for (let i = 0; i < 12; i++) {
            let h = hash2(this.index * 100 + i);
            let localZ = h * CHUNK_LEN;
            let side = hash2(this.index * 100 + i + 50) > 0.5 ? 1 : -1;
            let dist = 15 + hash2(this.index * 100 + i + 100) * 30;
            let cx = this.getCurveX(localZ);
            let y = this.getY(localZ);
            let type = hash2(this.index * 100 + i + 200);
            
            this.objects.push({
                x: cx + side * dist,
                y: y,
                z: this.zStart + localZ,
                type: type < 0.6 ? 'tree' : type < 0.8 ? 'building' : 'rock',
                scale: 0.8 + hash2(this.index * 100 + i + 300) * 1.5,
                colorVar: hash2(this.index * 100 + i + 400)
            });
        }
        
        // Traffic
        this.trafficCars = [];
        let numCars = Math.floor(hash2(this.index * 777) * 3);
        for (let i = 0; i < numCars; i++) {
            let lz = hash2(this.index * 333 + i * 77) * CHUNK_LEN;
            let lane = Math.floor(hash2(this.index * 444 + i * 88) * 3) - 1;
            let cx2 = this.getCurveX(lz);
            this.trafficCars.push({
                x: cx2 + lane * (ROAD_W / 2.5),
                y: this.getY(lz),
                z: this.zStart + lz,
                lane: lane,
                speed: 15 + hash2(this.index * 555 + i) * 25,
                colorR: hash2(this.index * 666 + i),
                colorG: hash2(this.index * 777 + i) * 0.5,
                colorB: hash2(this.index * 888 + i),
                localZ: lz
            });
        }
    }
    
    draw(identity) {
        drawMesh(this.mesh, identity);
        drawMesh(this.groundMesh, identity);
        if (this.barrierMeshL) drawMesh(this.barrierMeshL, identity);
        if (this.barrierMeshR) drawMesh(this.barrierMeshR, identity);
    }
    
    destroy() {
        // Clean up GL buffers
        let meshes = [this.mesh, this.groundMesh, this.barrierMeshL, this.barrierMeshR];
        for (let m of meshes) {
            if (m) {
                gl.deleteBuffer(m.vb);
                gl.deleteBuffer(m.nb);
                gl.deleteBuffer(m.cb);
                gl.deleteBuffer(m.ib);
            }
        }
    }
}

// Pre-built meshes for objects
let treeTrunk, treeTop1, treeTop2, treeTop3;
let carBody, carRoof, carWheel;
let buildingBox, rockMesh;

function buildObjectMeshes() {
    treeTrunk = buildCylinder(0.3, 3, 8, 0.4, 0.25, 0.1);
    treeTop1 = buildCone(2.0, 4, 8, 0.1, 0.5, 0.1);
    treeTop2 = buildCone(1.6, 3.5, 8, 0.05, 0.45, 0.08);
    treeTop3 = buildCone(1.3, 3, 8, 0.15, 0.55, 0.12);
    
    carBody = buildBox(2.0, 0.8, 4.0, 0.8, 0.1, 0.1);
    carRoof = buildBox(1.6, 0.6, 2.0, 0.6, 0.08, 0.08);
    carWheel = buildBox(0.3, 0.5, 0.5, 0.15, 0.15, 0.15);
    
    buildingBox = buildBox(1, 1, 1, 0.5, 0.5, 0.55);
    rockMesh = buildBox(1, 0.7, 1, 0.4, 0.38, 0.35);
}

// Game state
let state = 'menu'; // menu, playing
let score = 0;
let time = 0;

// Player car
let player = {
    x: 0,
    y: 0,
    z: 0,
    vx: 0,
    vz: 0,
    speed: 0,
    angle: 0, // heading
    steer: 0,
    accel: 0,
    maxSpeed: 80,
    engineForce: 45,
    brakeForce: 60,
    friction: 8,
    offRoadFriction: 25,
    turnSpeed: 2.2,
    driftFactor: 0
};

let keys = {};
window.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (e.code === 'Enter' && state !== 'playing') {
        state = 'playing';
        score = 0;
        player.x = 0; player.y = 0; player.z = 5;
        player.speed = 0; player.angle = 0; player.steer = 0;
        player.vx = 0; player.vz = 0;
        document.getElementById('message').textContent = '';
        // Reset chunks
        chunks = {};
    }
});
window.addEventListener('keyup', e => keys[e.code] = false);

// Chunks management
let chunks = {};
const VISIBLE_CHUNKS = 30;
const BEHIND_CHUNKS = 3;

function getChunk(index) {
    if (!chunks[index]) {
        let prev = chunks[index - 1];
        chunks[index] = new RoadChunk(index, prev);
    }
    return chunks[index];
}

function getWorldY(z) {
    let ci = Math.floor(z / CHUNK_LEN);
    let chunk = getChunk(ci);
    let localZ = z - ci * CHUNK_LEN;
    return chunk.getY(localZ);
}

function getWorldCurveX(z) {
    let ci = Math.floor(z / CHUNK_LEN);
    let chunk = getChunk(ci);
    let localZ = z - ci * CHUNK_LEN;
    return chunk.getCurveX(localZ);
}

function getRoadCenter(z) {
    let ci = Math.floor(z / CHUNK_LEN);
    let chunk = getChunk(ci);
    let localZ = z - ci * CHUNK_LEN;
    return chunk.getCurveX(localZ);
}

// Update
function update(dt) {
    if (state !== 'playing') return;
    
    dt = Math.min(dt, 0.05);
    time += dt;
    
    let accelInput = 0;
    let steerInput = 0;
    let braking = false;
    
    if (keys['ArrowUp'] || keys['KeyW']) accelInput = 1;
    if (keys['ArrowDown'] || keys['KeyS']) accelInput = -0.5;
    if (keys['ArrowLeft'] || keys['KeyA']) steerInput = -1;
    if (keys['ArrowRight'] || keys['KeyD']) steerInput = 1;
    if (keys['Space']) braking = true;
    
    // Steering
    let steerSpeed = player.turnSpeed * Math.min(1, player.speed / 20);
    player.steer += (steerInput * steerSpeed - player.steer * 3) * dt * 5;
    
    // Apply steering to angle
    if (Math.abs(player.speed) > 0.5) {
        player.angle += player.steer * dt * (player.speed > 0 ? 1 : -1);
    }
    
    // Check if on road
    let roadCenterX = getRoadCenter(player.z);
    let distFromCenter = Math.abs(player.x - roadCenterX);
    let onRoad = distFromCenter < ROAD_W;
    
    // Engine force
    if (accelInput > 0) {
        player.speed += player.engineForce * accelInput * dt;
    } else if (accelInput < 0) {
        player.speed += player.engineForce * accelInput * dt;
    }
    
    // Braking
    if (braking) {
        if (player.speed > 0) player.speed -= player.brakeForce * dt;
        else if (player.speed < 0) player.speed += player.brakeForce * dt;
        if (Math.abs(player.speed) < 1) player.speed = 0;
    }
    
    // Friction
    let fric = onRoad ? player.friction : player.offRoadFriction;
    if (player.speed > 0) {
        player.speed -= fric * dt;
        if (player.speed < 0) player.speed = 0;
    } else if (player.speed < 0) {
        player.speed += fric * dt;
        if (player.speed > 0) player.speed = 0;
    }
    
    // Off-road speed limit
    if (!onRoad && player.speed > player.maxSpeed * 0.3) {
        player.speed -= player.offRoadFriction * dt;
    }
    
    // Max speed
    player.speed = Math.max(-20, Math.min(player.maxSpeed, player.speed));
    
    // Move
    player.x += Math.sin(player.angle) * player.speed * dt;
    player.z += Math.cos(player.angle) * player.speed * dt;
    
    // Y position (follow terrain)
    let targetY = getWorldY(player.z);
    player.y += (targetY - player.y) * dt * 10;
    
    // Road auto-alignment (subtle pull toward road direction)
    let roadAngleSample = 0.5;
    let cx0 = getRoadCenter(player.z);
    let cx1 = getRoadCenter(player.z + roadAngleSample);
    let roadAngle = Math.atan2(cx1 - cx0, roadAngleSample);
    let angleDiff = roadAngle - player.angle;
    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
    if (onRoad && Math.abs(player.speed) > 5) {
        player.angle += angleDiff * dt * 1.5;
    }
    
    // Collision with traffic
    let chunkIdx = Math.floor(player.z / CHUNK_LEN);
    for (let ci = chunkIdx - 1; ci <= chunkIdx + 2; ci++) {
        let chunk = getChunk(ci);
        for (let tc of chunk.trafficCars) {
            let dx = player.x - tc.x;
            let dz = player.z - tc.z;
            let dist = Math.sqrt(dx * dx + dz * dz);
            if (dist < 2.5) {
                // Bump
                player.speed *= 0.3;
                let pushX = dx / Math.max(dist, 0.1) * 5;
                player.x += pushX * dt * 10;
            }
        }
    }
    
    // Barrier collision
    let barrierX_L = roadCenterX - ROAD_W - 1.2;
    let barrierX_R = roadCenterX + ROAD_W + 1.2;
    if (player.x < barrierX_L + 1.2) {
        player.x = barrierX_L + 1.2;
        player.speed *= 0.8;
        player.angle *= 0.9;
    }
    if (player.x > barrierX_R - 0.5) {
        player.x = barrierX_R - 0.5;
        player.speed *= 0.8;
        player.angle *= 0.9;
    }
    
    // Update traffic
    for (let ci2 = chunkIdx - BEHIND_CHUNKS; ci2 < chunkIdx + VISIBLE_CHUNKS; ci2++) {
        let chunk = getChunk(ci2);
        for (let tc of chunk.trafficCars) {
            tc.z += tc.speed * dt;
            let tlz = tc.z - chunk.zStart;
            tc.x = chunk.getCurveX(Math.max(0, Math.min(CHUNK_LEN, tlz))) + tc.lane * (ROAD_W / 2.5);
            tc.y = chunk.getY(Math.max(0, Math.min(CHUNK_LEN, tlz)));
        }
    }
    
    // Score
    score += player.speed * dt * 0.5;
    
    // UI
    let kmh = Math.abs(Math.round(player.speed * 3.6));
    document.getElementById('speed').textContent = kmh + ' km/h';
    document.getElementById('score').textContent = 'Score: ' + Math.round(score);
    
    let gear = player.speed < 5 ? 'N' : player.speed < 15 ? '1' : player.speed < 30 ? '2' : player.speed < 45 ? '3' : player.speed < 60 ? '4' : player.speed < 72 ? '5' : '6';
    document.getElementById('gear').textContent = gear;
}

// Render
function render() {
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    
    let aspect = canvas.width / canvas.height;
    let proj = perspective(Math.PI / 3, aspect, 0.5, 800);
    gl.uniformMatrix4fv(uProj, false, proj);
    
    // Camera behind player
    let camDist = 8;
    let camH = 4;
    let camX = player.x - Math.sin(player.angle) * camDist;
    let camZ = player.z - Math.cos(player.angle) * camDist;
    let camY = player.y + camH;
    
    let lookX = player.x + Math.sin(player.angle) * 10;
    let lookZ = player.z + Math.cos(player.angle) * 10;
    let lookY = player.y + 1.5;
    
    let view = lookAt([camX, camY, camZ], [lookX, lookY, lookZ], [0, 1, 0]);
    gl.uniformMatrix4fv(uView, false, view);
    
    gl.uniform3f(uLightDir, 0.3, 0.8, 0.5);
    gl.uniform3f(uFogColor, 0.05, 0.05, 0.15);
    gl.uniform1f(uTime, time);
    
    let identity = mat4();
    
    // Draw chunks
    let currentChunk = Math.floor(player.z / CHUNK_LEN);
    let chunksToRemove = [];
    
    for (let i = currentChunk - BEHIND_CHUNKS; i < currentChunk + VISIBLE_CHUNKS; i++) {
        let chunk = getChunk(i);
        chunk.draw(identity);
        
        // Draw objects
        for (let obj of chunk.objects) {
            let m = mat4();
            m = translate(m, obj.x, obj.y, obj.z);
            
            if (obj.type === 'tree') {
                let s = obj.scale;
                let tm = scaleM(m, s, s, s);
                drawMesh(treeTrunk, tm);
                let tm2 = translate(m, 0, 3 * s, 0);
                tm2 = scaleM(tm2, s, s, s);
                drawMesh(treeTop1, tm2);
                let tm3 = translate(m, 0, 5 * s, 0);
                tm3 = scaleM(tm3, s * 0.8, s * 0.8, s * 0.8);
                drawMesh(treeTop2, tm3);
            } else if (obj.type === 'building') {
                let s = obj.scale;
                let bm = scaleM(m, s * 3, s * 6, s * 3);
                bm = translate(bm, 0, 0.5, 0);
                drawMesh(buildingBox, bm);
            } else {
                let s = obj.scale;
                let rm = scaleM(m, s * 2, s * 1.5, s * 2);
                rm = translate(rm, 0, 0.35, 0);
                drawMesh(rockMesh, rm);
            }
        }
        
        // Draw traffic cars
        for (let tc of chunk.trafficCars) {
            let m2 = mat4();
            m2 = translate(m2, tc.x, tc.y + 0.5, tc.z);
            
            // Body with color
            let cbody = buildBox(2.0, 0.8, 4.0, tc.colorR, tc.colorG, tc.colorB);
            drawMesh(cbody, m2);
            // Quick cleanup - we'll do pooling in a smarter way
            gl.deleteBuffer(cbody.vb); gl.deleteBuffer(cbody.nb); gl.deleteBuffer(cbody.cb); gl.deleteBuffer(cbody.ib);
            
            let m3 = translate(m2, 0, 0.7, -0.3);
            drawMesh(carRoof, m3);
        }
    }
    
    // Draw player car
    {
        let m = mat4();
        m = translate(m, player.x, player.y + 0.5, player.z);
        m = rotateY(m, -player.angle);
        
        // Tilt based on steering
        drawMesh(carBody, m);
        
        let m2 = translate(m, 0, 0.7, -0.3);
        drawMesh(carRoof, m2);
        
        // Wheels
        for (let wx of [-1.1, 1.1]) {
            for (let wz of [-1.3, 1.3]) {
                let mw = translate(m, wx, -0.15, wz);
                drawMesh(carWheel, mw);
            }
        }
    }
    
    // Clean up old chunks
    for (let key in chunks) {
        let idx = parseInt(key);
        if (idx < currentChunk - BEHIND_CHUNKS - 2 || idx > currentChunk + VISIBLE_CHUNKS + 2) {
            chunks[key].destroy();
            delete chunks[key];
        }
    }
}

// Init
buildObjectMeshes();

// Main loop
let lastTime = 0;
function loop(timestamp) {
    let dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;
    if (dt > 0.1) dt = 0.016;
    
    resize();
    update(dt);
    render();
    requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
```
