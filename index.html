```html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Infinite 3D Car Racing</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { overflow: hidden; background: #000; font-family: 'Arial', sans-serif; }
canvas { display: block; }
#ui {
position: absolute; top: 0; left: 0; width: 100%; height: 100%;
pointer-events: none; color: white;
}
#speed {
position: absolute; bottom: 30px; right: 30px;
font-size: 48px; font-weight: bold;
text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
}
#score {
position: absolute; top: 20px; left: 20px;
font-size: 32px; font-weight: bold;
text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
}
#message {
position: absolute; top: 50%; left: 50%;
transform: translate(-50%, -50%);
font-size: 64px; font-weight: bold;
text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
text-align: center;
pointer-events: auto;
}
#controls {
position: absolute; bottom: 30px; left: 30px;
font-size: 14px; opacity: 0.7;
text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
}
#minimap {
position: absolute; top: 20px; right: 20px;
width: 150px; height: 150px;
border: 2px solid rgba(255,255,255,0.3);
border-radius: 50%;
overflow: hidden;
background: rgba(0,0,0,0.5);
}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="ui">
<div id="score">Score: 0</div>
<div id="speed">0 km/h</div>
<div id="controls">
‚Üë/W: Accelerate | ‚Üì/S: Brake<br>
‚Üê/A: Left | ‚Üí/D: Right<br>
Space: Handbrake | R: Reset
</div>
<div id="message">Press ENTER to Start</div>
<canvas id="minimap" width="150" height="150"></canvas>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const minimapCanvas = document.getElementById('minimap');
const minimapCtx = minimapCanvas.getContext('2d');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Game state
let gameState = 'waiting'; // waiting, playing, crashed
let score = 0;
let highScore = 0;
let frameCount = 0;

// Keys
const keys = {};
window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
    keys[e.code] = true;
    if (e.key === 'Enter' && gameState !== 'playing') startGame();
    if (e.key.toLowerCase() === 'r') resetCar();
});
window.addEventListener('keyup', e => {
    keys[e.key.toLowerCase()] = false;
    keys[e.code] = false;
});
window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
});

// Road generation
const SEGMENT_LENGTH = 200;
const ROAD_WIDTH = 2000;
const RUMBLE_WIDTH = 100;
const LANE_COUNT = 3;
const DRAW_DISTANCE = 300;
const FOV = 100;
const CAM_HEIGHT = 1500;
const CAM_DEPTH = 1 / Math.tan((FOV / 2) * Math.PI / 180);

let segments = [];
let totalSegments = 0;
let trackLength = 0;

// Car physics
let car = {
    x: 0, // lateral position (-1 to 1)
    z: 0, // position along track
    speed: 0,
    maxSpeed: SEGMENT_LENGTH * 60,
    accel: SEGMENT_LENGTH * 12,
    braking: SEGMENT_LENGTH * 24,
    decel: SEGMENT_LENGTH * 6,
    offRoadDecel: SEGMENT_LENGTH * 16,
    offRoadMaxSpeed: SEGMENT_LENGTH * 15,
    steering: 0,
    steerAngle: 0,
    bounce: 0,
    tilt: 0
};

// Traffic
let traffic = [];
const TRAFFIC_DENSITY = 0.3;

// Colors
const COLORS = {
    SKY: { top: '#0a0a2e', bottom: '#1a1a4e' },
    TREE: { trunk: '#4a2a0a', leaves: ['#0a5a0a', '#0a6a0a', '#0a4a0a'] },
    ROAD: { dark: '#333333', light: '#383838' },
    RUMBLE: { dark: '#FF0000', light: '#FFFFFF' },
    GRASS: { dark: '#0a5a0a', light: '#0a6a0a' },
    LANE: { dark: '#333333', light: '#CCCCCC' },
    FOG: '#0a0a2e',
    START: '#FFFFFF',
    FINISH: '#000000'
};

const CAR_COLORS = ['#ff3333', '#3333ff', '#33ff33', '#ffff33', '#ff33ff', '#33ffff', '#ff8833', '#8833ff'];

// Utility functions
function rand(min, max) { return Math.random() * (max - min) + min; }
function randInt(min, max) { return Math.floor(rand(min, max)); }
function interpolate(a, b, t) { return a + (b - a) * t; }
function exponentialFog(distance, density) { return 1 / Math.pow(Math.E, distance * distance * density); }
function percentRemaining(n, total) { return (n % total) / total; }
function increase(start, increment, max) {
    let result = start + increment;
    while (result >= max) result -= max;
    while (result < 0) result += max;
    return result;
}

function project(point, camX, camY, camZ, camDepth, width, height, roadWidth) {
    point.camera = {
        x: (point.world.x || 0) - camX,
        y: (point.world.y || 0) - camY,
        z: (point.world.z || 0) - camZ
    };
    if (point.camera.z <= 0) {
        point.screen = { x: 0, y: 0, w: 0, scale: 0 };
        return;
    }
    point.screen = {
        scale: camDepth / point.camera.z,
        x: Math.round(width / 2 + point.screen_scale * point.camera.x * width / 2),
        y: Math.round(height / 2 - point.screen_scale * point.camera.y * height / 2),
        w: Math.round(point.screen_scale * roadWidth * width / 2)
    };
    point.screen.scale = camDepth / point.camera.z;
    point.screen.x = Math.round(width / 2 + point.screen.scale * point.camera.x * width / 2);
    point.screen.y = Math.round(height / 2 - point.screen.scale * point.camera.y * height / 2);
    point.screen.w = Math.round(point.screen.scale * roadWidth * width / 2);
}

// Road building
function addSegment(curve, y) {
    let n = segments.length;
    segments.push({
        index: n,
        p1: { world: { x: 0, y: lastY(), z: n * SEGMENT_LENGTH }, screen: {}, camera: {} },
        p2: { world: { x: 0, y: y, z: (n + 1) * SEGMENT_LENGTH }, screen: {}, camera: {} },
        curve: curve,
        sprites: [],
        cars: [],
        color: Math.floor(n / 3) % 2 ? 'dark' : 'light',
        looped: false
    });
}

function lastY() {
    return segments.length === 0 ? 0 : segments[segments.length - 1].p2.world.y;
}

function addRoad(enter, hold, leave, curve, y) {
    let startY = lastY();
    let endY = startY + (y || 0) * SEGMENT_LENGTH;
    let total = enter + hold + leave;
    for (let n = 0; n < enter; n++) {
        addSegment(interpolate(0, curve, n / enter), interpolate(startY, endY, n / total));
    }
    for (let n = 0; n < hold; n++) {
        addSegment(curve, interpolate(startY, endY, (enter + n) / total));
    }
    for (let n = 0; n < leave; n++) {
        addSegment(interpolate(curve, 0, n / leave), interpolate(startY, endY, (enter + hold + n) / total));
    }
}

function addStraight(num) { addRoad(num || 25, num || 25, num || 25, 0, 0); }
function addCurve(num, curve, height) { addRoad(num || 25, num || 25, num || 25, curve, height); }
function addHill(num, height) { addRoad(num || 25, num || 25, num || 25, 0, height); }
function addDownhill(num, height) { addHill(num, -height); }
function addSCurves() {
    addRoad(10, 15, 10, -3, 3);
    addRoad(10, 15, 10, 5, -5);
    addRoad(10, 15, 10, 3, 3);
    addRoad(10, 15, 10, -5, -3);
    addRoad(10, 15, 10, -2, 0);
}

function addSprite(n, sprite, offset) {
    if (n < segments.length) {
        segments[n].sprites.push({ source: sprite, offset: offset });
    }
}

function addTreeSprites() {
    for (let n = 10; n < segments.length; n += randInt(3, 8)) {
        let side = Math.random() > 0.5 ? 1 : -1;
        let offset = side * (1.2 + Math.random() * 3);
        addSprite(n, { type: 'tree', variant: randInt(0, 3), height: rand(200, 500) }, offset);
    }
    // Add buildings/signs occasionally
    for (let n = 20; n < segments.length; n += randInt(30, 80)) {
        let side = Math.random() > 0.5 ? 1 : -1;
        addSprite(n, { type: 'building', variant: randInt(0, 4), height: rand(300, 800) }, side * (1.5 + Math.random() * 2));
    }
}

function buildTrack() {
    segments = [];

    addStraight(50);
    addCurve(30, 3, 0);
    addHill(30, 5);
    addStraight(20);
    addCurve(40, -4, 0);
    addDownhill(20, 3);
    addSCurves();
    addStraight(30);
    addCurve(25, 5, 2);
    addHill(40, 8);
    addCurve(30, -3, -3);
    addStraight(40);
    addCurve(50, -6, 0);
    addDownhill(30, 5);
    addStraight(25);
    addCurve(35, 4, 3);
    addSCurves();
    addHill(25, -4);
    addStraight(50);
    addCurve(40, 7, 0);
    addDownhill(40, 8);
    addStraight(30);
    addCurve(30, -5, 2);
    addHill(30, 6);
    addSCurves();
    addStraight(50);

    totalSegments = segments.length;
    trackLength = totalSegments * SEGMENT_LENGTH;

    addTreeSprites();
}

function findSegment(z) {
    return segments[Math.floor(z / SEGMENT_LENGTH) % totalSegments];
}

// Traffic generation
function resetTraffic() {
    traffic = [];
    for (let n = 0; n < totalSegments * TRAFFIC_DENSITY; n++) {
        let segIndex = randInt(0, totalSegments);
        let t = {
            offset: rand(-0.8, 0.8),
            z: segIndex * SEGMENT_LENGTH + rand(0, SEGMENT_LENGTH),
            speed: rand(car.maxSpeed / 8, car.maxSpeed / 4),
            color: CAR_COLORS[randInt(0, CAR_COLORS.length)],
            type: randInt(0, 3)
        };
        let seg = segments[segIndex % totalSegments];
        seg.cars.push(t);
        traffic.push(t);
    }
}

// Start game
function startGame() {
    gameState = 'playing';
    score = 0;
    buildTrack();
    resetCar();
    resetTraffic();
    document.getElementById('message').textContent = '';
}

function resetCar() {
    car.x = 0;
    car.z = 0;
    car.speed = 0;
    car.steering = 0;
    car.steerAngle = 0;
    car.bounce = 0;
    car.tilt = 0;
    if (gameState === 'crashed') {
        gameState = 'playing';
        document.getElementById('message').textContent = '';
    }
}

// Update
function update(dt) {
    if (gameState !== 'playing') return;

    frameCount++;
    let seg = findSegment(car.z);
    let speedPercent = car.speed / car.maxSpeed;
    let dx = dt * 2 * speedPercent;
    let offRoad = Math.abs(car.x) > 1.0;

    // Steering
    if (keys['arrowleft'] || keys['a']) {
        car.steerAngle = interpolate(car.steerAngle, -1, dt * 5);
    } else if (keys['arrowright'] || keys['d']) {
        car.steerAngle = interpolate(car.steerAngle, 1, dt * 5);
    } else {
        car.steerAngle = interpolate(car.steerAngle, 0, dt * 5);
    }

    car.x += car.steerAngle * dx;

    // Auto-steer with curves
    car.x -= (seg.curve * speedPercent * dt * 2.5);

    // Acceleration
    if (keys['arrowup'] || keys['w']) {
        car.speed += car.accel * dt;
    } else if (keys['arrowdown'] || keys['s']) {
        car.speed -= car.braking * dt;
    } else {
        car.speed -= car.decel * dt;
    }

    // Handbrake
    if (keys[' ']) {
        car.speed -= car.braking * 0.7 * dt;
        car.steerAngle *= 1.5; // Oversteer
    }

    // Off-road
    if (offRoad) {
        car.speed -= car.offRoadDecel * dt;
        if (car.speed > car.offRoadMaxSpeed) {
            car.speed = car.offRoadMaxSpeed;
        }
    }

    // Clamp
    car.speed = Math.max(0, Math.min(car.speed, car.maxSpeed));
    car.x = Math.max(-3, Math.min(3, car.x));

    // Position
    car.z = increase(car.z, car.speed * dt, trackLength);

    // Tilt for visual effect
    car.tilt = interpolate(car.tilt, car.steerAngle * speedPercent * 0.1, dt * 8);

    // Bounce
    car.bounce = Math.sin(frameCount * 0.3) * speedPercent * 3;
    if (offRoad) car.bounce *= 3;

    // Segment height interpolation (hills)
    let segPercent = percentRemaining(car.z, SEGMENT_LENGTH);
    let carY = interpolate(seg.p1.world.y, seg.p2.world.y, segPercent);

    // Score
    score += car.speed * dt * 0.001;

    // Traffic collision check
    let carW = 0.4; // car width in road units
    for (let i = 0; i < traffic.length; i++) {
        let t = traffic[i];
        let tSeg = findSegment(t.z);
        if (Math.abs(t.z - car.z) < 500 || Math.abs(t.z - car.z) > trackLength - 500) {
            let actualDist = t.z - car.z;
            if (actualDist < 0) actualDist += trackLength;
            if (actualDist < 400 && actualDist > 0) {
                if (Math.abs(car.x - t.offset) < 0.7) {
                    // Collision!
                    if (car.speed > car.maxSpeed * 0.1) {
                        car.speed *= 0.3;
                        score -= 50;
                        if (score < 0) score = 0;
                    }
                }
            }
        }
    }

    // Update traffic positions
    for (let i = 0; i < traffic.length; i++) {
        let t = traffic[i];
        let oldSeg = findSegment(t.z);
        t.z = increase(t.z, t.speed * dt, trackLength);
        let newSeg = findSegment(t.z);
        if (oldSeg !== newSeg) {
            let idx = oldSeg.cars.indexOf(t);
            if (idx !== -1) oldSeg.cars.splice(idx, 1);
            newSeg.cars.push(t);
        }
    }

    // UI
    document.getElementById('speed').textContent = Math.round(car.speed / 100) + ' km/h';
    document.getElementById('score').textContent = 'Score: ' + Math.round(score);
}

// Rendering helpers
function drawPolygon(ctx, x1, y1, x2, y2, x3, y3, x4, y4, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.lineTo(x3, y3);
    ctx.lineTo(x4, y4);
    ctx.closePath();
    ctx.fill();
}

function drawSegment(width, height, lanes, x1, y1, w1, x2, y2, w2, fog, colors) {
    let r1 = w1 / Math.max(6, 2 * lanes);
    let r2 = w2 / Math.max(6, 2 * lanes);
    let l1 = w1 / Math.max(32, 8 * lanes);
    let l2 = w2 / Math.max(32, 8 * lanes);

    // Grass
    ctx.fillStyle = colors.grass;
    ctx.fillRect(0, y2, width, y1 - y2);

    // Rumble strips
    drawPolygon(ctx, x1 - w1 - r1, y1, x1 - w1, y1, x2 - w2, y2, x2 - w2 - r2, y2, colors.rumble);
    drawPolygon(ctx, x1 + w1 + r1, y1, x1 + w1, y1, x2 + w2, y2, x2 + w2 + r2, y2, colors.rumble);

    // Road
    drawPolygon(ctx, x1 - w1, y1, x1 + w1, y1, x2 + w2, y2, x2 - w2, y2, colors.road);

    // Lane markings
    if (colors.lane) {
        let lw1 = w1 * 2 / lanes;
        let lw2 = w2 * 2 / lanes;
        let lx1 = x1 - w1 + lw1;
        let lx2 = x2 - w2 + lw2;
        for (let lane = 1; lane < lanes; lane++) {
            drawPolygon(ctx,
                lx1 - l1 / 2, y1, lx1 + l1 / 2, y1,
                lx2 + l2 / 2, y2, lx2 - l2 / 2, y2,
                colors.lane);
            lx1 += lw1;
            lx2 += lw2;
        }
    }

    // Fog overlay
    if (fog < 1) {
        ctx.fillStyle = COLORS.FOG;
        ctx.globalAlpha = 1 - fog;
        ctx.fillRect(0, y2, width, y1 - y2);
        ctx.globalAlpha = 1;
    }
}

function drawSprite(sprite, scale, destX, destY, offsetX, clipY) {
    let s = sprite.source;
    let h = s.height * scale;
    let w = (s.type === 'tree' ? 80 : 120) * scale;

    destX += offsetX * scale;
    destY -= h;

    if (clipY && destY + h > clipY) {
        h = clipY - destY;
    }
    if (h <= 0) return;

    // Draw sprite based on type
    if (s.type === 'tree') {
        // Trunk
        ctx.fillStyle = COLORS.TREE.trunk;
        ctx.fillRect(destX - w * 0.1, destY + h * 0.5, w * 0.2, h * 0.5);
        // Leaves
        ctx.fillStyle = COLORS.TREE.leaves[s.variant % 3];
        ctx.beginPath();
        ctx.arc(destX, destY + h * 0.3, w * 0.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(destX - w * 0.2, destY + h * 0.45, w * 0.35, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(destX + w * 0.2, destY + h * 0.4, w * 0.4, 0, Math.PI * 2);
        ctx.fill();
    } else if (s.type === 'building') {
        let colors = ['#555', '#666', '#777', '#888'];
        ctx.fillStyle = colors[s.variant % 4];
        ctx.fillRect(destX - w * 0.5, destY, w, h);
        // Windows
        ctx.fillStyle = '#FFE44D';
        let rows = Math.floor(h / 30);
        let cols = Math.floor(w / 25);
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                if (Math.random() > 0.3) {
                    ctx.fillRect(
                        destX - w * 0.4 + c * (w / cols),
                        destY + 10 + r * (h / rows),
                        w / cols * 0.5, h / rows * 0.5
                    );
                }
            }
        }
    }
}

function drawTrafficCar(t, scale, destX, destY, clipY) {
    let w = 60 * scale;
    let h = 40 * scale;
    let top = destY - h;

    if (clipY && top + h > clipY) return;
    if (h < 2) return;

    // Car body
    ctx.fillStyle = t.color;
    ctx.fillRect(destX - w, top, w * 2, h);

    // Roof
    ctx.fillStyle = shadeColor(t.color, -30);
    ctx.fillRect(destX - w * 0.6, top - h * 0.5, w * 1.2, h * 0.5);

    // Wheels
    ctx.fillStyle = '#111';
    ctx.fillRect(destX - w * 1.05, top + h * 0.6, w * 0.3, h * 0.4);
    ctx.fillRect(destX + w * 0.75, top + h * 0.6, w * 0.3, h * 0.4);

    // Windshield
    ctx.fillStyle = '#88CCFF';
    ctx.fillRect(destX - w * 0.5, top - h * 0.45, w * 1.0, h * 0.35);

    // Tail lights
    ctx.fillStyle = '#FF0000';
    ctx.fillRect(destX - w, top + h * 0.1, w * 0.15, h * 0.3);
    ctx.fillRect(destX + w * 0.85, top + h * 0.1, w * 0.15, h * 0.3);
}

function shadeColor(color, percent) {
    let num = parseInt(color.replace('#', ''), 16);
    let r = Math.min(255, Math.max(0, (num >> 16) + percent));
    let g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + percent));
    let b = Math.min(255, Math.max(0, (num & 0x0000FF) + percent));
    return '#' + (0x1000000 + r * 0x10000 + g * 0x100 + b).toString(16).slice(1);
}

function drawPlayerCar() {
    let w = canvas.width;
    let h = canvas.height;
    let cx = w / 2;
    let carY = h * 0.78 + car.bounce;
    let steer = car.steerAngle;
    let speed = car.speed / car.maxSpeed;

    ctx.save();
    ctx.translate(cx, carY);
    ctx.rotate(car.tilt);

    let carW = 70;
    let carH = 40;

    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.ellipse(0, carH + 5, carW + 10, 10, 0, 0, Math.PI * 2);
    ctx.fill();

    // Main body
    let bodyGrad = ctx.createLinearGradient(-carW, -carH, carW, carH);
    bodyGrad.addColorStop(0, '#cc0000');
    bodyGrad.addColorStop(0.5, '#ff2222');
    bodyGrad.addColorStop(1, '#aa0000');
    ctx.fillStyle = bodyGrad;
    
    // Body shape
    ctx.beginPath();
    ctx.moveTo(-carW, carH * 0.3);
    ctx.lineTo(-carW + 5, -carH * 0.2);
    ctx.lineTo(-carW * 0.6, -carH * 0.6);
    ctx.lineTo(-carW * 0.3, -carH);
    ctx.lineTo(carW * 0.3, -carH);
    ctx.lineTo(carW * 0.6, -carH * 0.6);
    ctx.lineTo(carW - 5, -carH * 0.2);
    ctx.lineTo(carW, carH * 0.3);
    ctx.lineTo(carW, carH);
    ctx.lineTo(-carW, carH);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = '#880000';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Windshield
    ctx.fillStyle = 'rgba(100, 180, 255, 0.8)';
    ctx.beginPath();
    ctx.moveTo(-carW * 0.55, -carH * 0.55);
    ctx.lineTo(-carW * 0.25, -carH * 0.95);
    ctx.lineTo(carW * 0.25, -carH * 0.95);
    ctx.lineTo(carW * 0.55, -carH * 0.55);
    ctx.closePath();
    ctx.fill();

    // Roof
    ctx.fillStyle = '#dd1111';
    ctx.fillRect(-carW * 0.4, -carH * 0.5, carW * 0.8, carH * 0.3);

    // Headlights
    ctx.fillStyle = '#FFFF88';
    ctx.beginPath();
    ctx.arc(-carW * 0.7, -carH * 0.1, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(carW * 0.7, -carH * 0.1, 6, 0, Math.PI * 2);
    ctx.fill();

    // Tail lights
    ctx.fillStyle = speed > 0 && (keys['arrowdown'] || keys['s'] || keys[' ']) ? '#FF0000' : '#880000';
    ctx.fillRect(-carW + 2, carH * 0.5, 12, 8);
    ctx.fillRect(carW - 14, carH * 0.5, 12, 8);

    // Wheels
    ctx.fillStyle = '#222';
    let wheelOffset = steer * 5;
    ctx.save();
    ctx.translate(-carW - 5, -carH * 0.1);
    ctx.rotate(wheelOffset * 0.1);
    ctx.fillRect(-5, -8, 10, 16);
    ctx.restore();
    ctx.save();
    ctx.translate(carW + 5, -carH * 0.1);
    ctx.rotate(wheelOffset * 0.1);
    ctx.fillRect(-5, -8, 10, 16);
    ctx.restore();

    ctx.fillRect(-carW - 5, carH * 0.4, 10, 16);
    ctx.fillRect(carW - 5, carH * 0.4, 10, 16);

    // Speed lines
    if (speed > 0.5) {
        ctx.globalAlpha = (speed - 0.5) * 2;
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 1;
        for (let i = 0; i < 5; i++) {
            let lx = rand(-carW, carW);
            ctx.beginPath();
            ctx.moveTo(lx, carH);
            ctx.lineTo(lx + rand(-5, 5), carH + rand(20, 60) * speed);
            ctx.stroke();
        }
        ctx.globalAlpha = 1;
    }

    ctx.restore();
}

// Draw sky with gradient and stars
function drawBackground() {
    let skyGrad = ctx.createLinearGradient(0, 0, 0, canvas.height * 0.5);
    skyGrad.addColorStop(0, '#000011');
    skyGrad.addColorStop(0.3, '#0a0a3e');
    skyGrad.addColorStop(0.7, '#1a1a5e');
    skyGrad.addColorStop(1, '#2a1a4e');
    ctx.fillStyle = skyGrad;
    ctx.fillRect(0, 0, canvas.width, canvas.height * 0.5);

    // Stars
    if (frameCount === 0 || !window._stars) {
        window._stars = [];
        for (let i = 0; i < 100; i++) {
            window._stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height * 0.4,
                r: Math.random() * 2,
                twinkle: Math.random() * Math.PI * 2
            });
        }
    }
    ctx.fillStyle = '#FFF';
    for (let star of window._stars) {
        let alpha = 0.5 + 0.5 * Math.sin(frameCount * 0.02 + star.twinkle);
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.r, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Moon
    ctx.fillStyle = '#FFFFCC';
    ctx.beginPath();
    ctx.arc(canvas.width * 0.8, canvas.height * 0.12, 30, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#EEEEAA';
    ctx.beginPath();
    ctx.arc(canvas.width * 0.8 + 5, canvas.height * 0.12 - 3, 28, 0, Math.PI * 2);
    ctx.fill();

    // Mountains/hills silhouette
    ctx.fillStyle = '#0a0a1e';
    ctx.beginPath();
    ctx.moveTo(0, canvas.height * 0.5);
    let mX = 0;
    while (mX < canvas.width + 100) {
        let mH = canvas.height * 0.5 - Math.sin(mX * 0.003 + 1) * 40 - Math.sin(mX * 0.007) * 25 - Math.sin(mX * 0.001 + 2) * 60;
        ctx.lineTo(mX, mH);
        mX += 5;
    }
    ctx.lineTo(canvas.width, canvas.height * 0.5);
    ctx.closePath();
    ctx.fill();

    // City silhouette
    ctx.fillStyle = '#050510';
    ctx.beginPath();
    ctx.moveTo(0, canvas.height * 0.5);
    mX = 0;
    while (mX < canvas.width + 50) {
        let buildingH = 10 + Math.abs(Math.sin(mX * 0.01 + 3)) * 30;
        ctx.lineTo(mX, canvas.height * 0.5 - buildingH);
        ctx.lineTo(mX + rand(10, 30), canvas.height * 0.5 - buildingH);
        ctx.lineTo(mX + rand(10, 30), canvas.height * 0.5 - buildingH + rand(5, 15));
        mX += rand(15, 40);
    }
    ctx.lineTo(canvas.width, canvas.height * 0.5);
    ctx.closePath();
    ctx.fill();
}

// Draw minimap
function drawMinimap() {
    minimapCtx.clearRect(0, 0, 150, 150);

    let cx = 75, cy = 75, radius = 60;

    // Background
    minimapCtx.fillStyle = 'rgba(0,30,0,0.7)';
    minimapCtx.beginPath();
    minimapCtx.arc(cx, cy, radius, 0, Math.PI * 2);
    minimapCtx.fill();

    // Draw track portion around player
    let playerSeg = Math.floor(car.z / SEGMENT_LENGTH) % totalSegments;
    let lookAhead = 100;
    let lookBehind = 30;

    let prevX = cx, prevY = cy + radius * 0.8;
    let heading = 0;

    minimapCtx.strokeStyle = '#555';
    minimapCtx.lineWidth = 4;
    minimapCtx.beginPath();
    minimapCtx.moveTo(prevX, prevY);

    for (let i = -lookBehind; i < lookAhead; i++) {
        let idx = ((playerSeg + i) % totalSegments + totalSegments) % totalSegments;
        let seg = segments[idx];
        heading += seg.curve * 0.02;
        let step = 1.2;
        let nx = prevX + Math.sin(heading) * step;
        let ny = prevY - Math.cos(heading) * step;
        minimapCtx.lineTo(nx, ny);
        prevX = nx;
        prevY = ny;
    }
    minimapCtx.stroke();

    // Draw traffic dots
    for (let t of traffic) {
        let tSeg = Math.floor(t.z / SEGMENT_LENGTH) % totalSegments;
        let diff = tSeg - playerSeg;
        if (diff > totalSegments / 2) diff -= totalSegments;
        if (diff < -totalSegments / 2) diff += totalSegments;
        if (Math.abs(diff) < lookAhead) {
            let px = cx, py = cy + radius * 0.8;
            let h = 0;
            let start = Math.min(0, diff);
            let end = Math.max(0, diff);
            for (let j = -lookBehind; j < diff; j++) {
                let jdx = ((playerSeg + j) % totalSegments + totalSegments) % totalSegments;
                h += segments[jdx].curve * 0.02;
                px += Math.sin(h) * 1.2;
                py -= Math.cos(h) * 1.2;
            }
            minimapCtx.fillStyle = t.color;
            minimapCtx.beginPath();
            minimapCtx.arc(px, py, 2, 0, Math.PI * 2);
            minimapCtx.fill();
        }
    }

    // Player dot
    minimapCtx.fillStyle = '#FF0000';
    minimapCtx.beginPath();
    let px = cx, py = cy + radius * 0.8;
    minimapCtx.arc(px, py, 4, 0, Math.PI * 2);
    minimapCtx.fill();

    // Border
    minimapCtx.strokeStyle = 'rgba(255,255,255,0.3)';
    minimapCtx.lineWidth = 2;
    minimapCtx.beginPath();
    minimapCtx.arc(cx, cy, radius + 5, 0, Math.PI * 2);
    minimapCtx.stroke();
}

// Main render
function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (gameState === 'waiting') {
        drawBackground();
        document.getElementById('message').innerHTML = 'üèéÔ∏è INFINITE RACER üèéÔ∏è<br><span style="font-size:24px">Press ENTER to Start</span>';
        return;
    }

    let baseSegment = findSegment(car.z);
    let baseSegPercent = percentRemaining(car.z, SEGMENT_LENGTH);
    let playerSegment = findSegment(car.z + CAM_HEIGHT);
    let playerY = interpolate(baseSegment.p1.world.y, baseSegment.p2.world.y, baseSegPercent);
    let camH = CAM_HEIGHT + playerY;

    let maxY = canvas.height;
    let x = 0;
    let dx = -(baseSegment.curve * baseSegPercent);

    drawBackground();

    // Render segments from far to near
    let startIndex = Math.floor(car.z / SEGMENT_LENGTH);

    for (let n = 0; n < DRAW_DISTANCE; n++) {
        let segIndex = (startIndex + n) % totalSegments;
        let seg = segments[segIndex];
        let looped = (startIndex + n) >= totalSegments;

        let camZ = car.z - (looped ? trackLength : 0);

        project(seg.p1, car.x * ROAD_WIDTH - x, camH, camZ, CAM_DEPTH, canvas.width, canvas.height, ROAD_WIDTH);
        project(seg.p2, car.x * ROAD_WIDTH - x - dx, camH, camZ, CAM_DEPTH, canvas.width, canvas.height, ROAD_WIDTH);

        x += dx;
        dx += seg.curve;

        if (seg.p1.camera.z <= CAM_DEPTH || seg.p2.screen.y >= seg.p1.screen.y || seg.p2.screen.y >= maxY) continue;

        let fogDensity = 0.00003;
        let fog = exponentialFog(n / DRAW_DISTANCE, fogDensity * 1000);

        let colors = {
            road: seg.color === 'dark' ? COLORS.ROAD.dark : COLORS.ROAD.light,
            grass: seg.color === 'dark' ? COLORS.GRASS.dark : COLORS.GRASS.light,
            rumble: seg.color === 'dark' ? COLORS.RUMBLE.dark : COLORS.RUMBLE.light,
            lane: seg.color === 'dark' ? null : COLORS.LANE.light
        };

        drawSegment(
            canvas.width, canvas.height, LANE_COUNT,
            seg.p1.screen.x, seg.p1.screen.y, seg.p1.screen.w,
            seg.p2.screen.x, seg.p2.screen.y, seg.p2.screen.w,
            fog, colors
        );

        maxY = seg.p2.screen.y;
    }

    // Render sprites and traffic (near to far for correct overlap)
    for (let n = DRAW_DISTANCE - 1; n > 0; n--) {
        let segIndex = (startIndex + n) % totalSegments;
        let seg = segments[segIndex];

        // Sprites
        for (let i = 0; i < seg.sprites.length; i++) {
            let sprite = seg.sprites[i];
            let spriteScale = seg.p1.screen.scale;
            let spriteX = seg.p1.screen.x + (spriteScale * sprite.offset * ROAD_WIDTH * canvas.width / 2);
            drawSprite(sprite, spriteScale * 3000, spriteX, seg.p1.screen.y, 0, null);
        }

        // Traffic cars
        for (let i = 0; i < seg.cars.length; i++) {
            let t = seg.cars[i];
            let spriteScale = seg.p1.screen.scale;
            let spriteX = seg.p1.screen.x + (spriteScale * t.offset * ROAD_WIDTH * canvas.width / 2);
            drawTrafficCar(t, spriteScale * 3000, spriteX, seg.p1.screen.y, null);
        }
    }

    // Draw player car
    drawPlayerCar();

    // HUD elements
    drawSpeedometer();
    drawMinimap();
}

function drawSpeedometer() {
    let x = canvas.width - 120;
    let y = canvas.height - 120;
    let r = 60;
    let speed = car.speed / car.maxSpeed;

    // Background
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.beginPath();
    ctx.arc(x, y, r + 5, 0, Math.PI * 2);
    ctx.fill();

    // Gauge arc
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 8;
    ctx.beginPath();
    ctx.arc(x, y, r - 10, Math.PI * 0.8, Math.PI * 2.2);
    ctx.stroke();

    // Speed arc
    let speedAngle = Math.PI * 0.8 + speed * Math.PI * 1.4;
    let gradient = ctx.createLinearGradient(x - r, y, x + r, y);
    gradient.addColorStop(0, '#00FF00');
    gradient.addColorStop(0.5, '#FFFF00');
    gradient.addColorStop(1, '#FF0000');
    ctx.strokeStyle = gradient;
    ctx.lineWidth = 8;
    ctx.beginPath();
    ctx.arc(x, y, r - 10, Math.PI * 0.8, speedAngle);
    ctx.stroke();

    // Needle
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(speedAngle);
    ctx.fillStyle = '#FF3333';
    ctx.beginPath();
    ctx.moveTo(-3, 0);
    ctx.lineTo(0, -(r - 15));
    ctx.lineTo(3, 0);
    ctx.fill();
    ctx.restore();

    // Center dot
    ctx.fillStyle = '#FFF';
    ctx.beginPath();
    ctx.arc(x, y, 5, 0, Math.PI * 2);
    ctx.fill();

    // Gear indicator
    let gear = speed < 0.15 ? 1 : speed < 0.3 ? 2 : speed < 0.5 ? 3 : speed < 0.7 ? 4 : speed < 0.85 ? 5 : 6;
    ctx.fillStyle = '#FFF';
    ctx.font = 'bold 20px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(gear, x, y + 25);
}

// Game loop
let lastTime = 0;
function gameLoop(timestamp) {
    let dt = Math.min(1 / 30, (timestamp - lastTime) / 1000);
    lastTime = timestamp;

    update(dt);
    render();

    requestAnimationFrame(gameLoop);
}

// Initialize
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
```
